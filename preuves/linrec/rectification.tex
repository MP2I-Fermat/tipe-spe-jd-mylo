\section{Rectification}

\subsection{Introduction}

Notre but dans cette section sera de développer un algorithme permettant de
rectifier, c'est-à-dire de rendre récursivement terminal, des fonctions
\texttt{OCaml}. On visera pour cela de mettre les fonction récursives sous forme
de \href{https://en.wikipedia.org/wiki/Continuation-passing_style}{\textit{Continuation Passing Style} (CPS)}.

L'idée est de les transformer en fonctions prenant un argument de plus: une
\textit{continuation}, que la fonction appelle avec son résultat en dernier au
lieu de renvoyer son résultat directement. On peut ainsi garantir que tout appel
récursif est \textit{terminal} (cf. ci-dessous) en passant toute la logique qui
le suivait précédemment sous forme d'une continuation.

\subsection{R\'ecursivit\'e terminale}

\begin{definition}
    Ensemble de variables rectifiant une forme linéaire.
    \newline
    Soit $l$ une forme linéaire correcte. On dit que $l$ est rectifiable par un
    ensemble de noms de variables $E$ lorsque pour tout appel de fonction
    $g\ arg_1 \ldots\ arg_n$ contenu dans $l$, s'il existe un contexte $c$ tel
    que Eval($l$, $c$) conduise à un appel Eval\_élément($g$, $c'$) et que
    l'appel Eval\_élément($g$, $c'$) conduise à un appel Eval($l$, $c''$), alors
    l'unique variable dans $g$ est dans $E$ ($g$ est forcément réduit à un
    couple $(p, e)$ avec $e$ constructeur d'arité nulle car $l$ est correcte, et
    $e$ ne peut pas être une constante car il doit être à valeurs
    fonctionnelles).

    \textit{Intuitivement, cela correspond à dire que $E$ contient les noms des
        fonctions qui pourraient conduire à un appel récursif de $l$.}
\end{definition}

\begin{definition}
    On dit qu'un ensemble de fonctions $\{f_1, \ldots, f_n\}$ définies par
    $f_i : x_1, \ldots, x_n \rightarrow Eval(l_i, [x_1 \rightarrow x_1, \ldots, x_n \rightarrow x_n])$
    sont \textit{mutuellement récursives terminales} lorsqu'il existe un
    ensemble de noms de variables $E$ qui rectifie tous les $l_i$ tel que pour
    toute variable $g$ dans $E$, pour toute forme linéaire $l_i$ avec
    $i \in \lBrack 1; n \rBrack$, tout appel à $g$ dans $l_i$ est terminal.
\end{definition}

\begin{definition}
    On dit qu'une fonction $f$ définie par
    $f : x_1, \ldots, x_n \rightarrow Eval(l, [x_1 \rightarrow x_1, \ldots, x_n \rightarrow x_n])$
    est récursive terminale lorsque $\{f\}$ est mutuellement récursif terminal.
\end{definition}

\begin{example}
    Considérons
    \begin{align*}
        f : l \rightarrow Eval \left(
        \begin{aligned}
             & a_1 := \texttt{List.is\_empty}\ l                                                     \\
             & a_2 := \texttt{if}\ a_1\ \texttt{then true else}\ \left(\begin{aligned}
                                                                                & a_3 := \texttt{List.tl}\ l \\
                                                                                & a_4 := f\ a_3              \\
                                                                                & a_5 := \texttt{not}\ a_4
                                                                           \end{aligned}
            \right)
        \end{aligned}, [l \rightarrow l]
        \right)
    \end{align*}

    Cette fonction calcule si la liste donnée en argument est de longueur paire.

    Elle n'est pas récursive terminale car si le corps de $f$ est rectifiable
    par un ensemble $E$, alors on a forcément $f \in E$ (l'appel $f\ a_3$
    conduit à l'évaluation du corps de $f$). Or l'appel $f\ a_3$ n'est pas
    terminal donc $f$ n'est pas récursive terminale.

    \bigbreak

    Considérons maintenant
    \begin{align*}
        g : l \rightarrowtail \textnormal{Eval} \left(
        \begin{aligned}
             & a_1 := \texttt{List.length}\ l                                     \\
             & a_2 := a_1 = 0                                                     \\
             & a_3 := \texttt{if}\ a_2\ \texttt{then failwith "Liste vide"}       \\
             & a_4 := a_1 = 1                                                     \\
             & a_5 := \texttt{List.hd}\ l                                         \\
             & a_6 := \texttt{List.tl}\ l                                         \\
             & a_7 := \texttt{if}\ a_4\ \texttt{then}\ a_5\ \texttt{else}\ g\ a_6
        \end{aligned}, [l \rightarrow l]
        \right)
    \end{align*}

    Cette fonction calcule le dernier élément de la liste donnée en paramètre.
    Elle est récursive terminale car son corps est rectifiable par $\{g\}$ (les
    appels \texttt{List.length}, \texttt{failwith}, \texttt{List.hd} et
    \texttt{List.tl} n'appellent jamais $g$) et l'appel $g\ a_6$ est terminal.
\end{example}

\subsection{Rectification}

\begin{definition}
    Formes lin\'eaires \'equivalentes
    \newline
    On dit que deux formes lin\'eaires $l_1$ et $l_2$ sont
    \textit{\'equivalentes} lorsque Eval($l_1$, $c$) a le m\^eme r\'esultat que
    Eval($l_2$, $c$) pour tout contexte $c$.
\end{definition}

On introduit alors un algorithme permettant de \textit{rectifier} une forme
lin\'eaire $l$, c'est \`a dire de calculer une forme lin\'eaire r\'ecursive
terminale \'equivalente \`a $l$.

\begin{algorithm}[H]
    \caption{Rectifier}
    \Entree{
        Une forme lin\'eaire correcte $l$, un ensemble de variables
        rectifiable $E$, un nom de variable non utilisée dans $l$ $cont$ et une
        fonction injective $nouveau\_nom$ de $E$ dans les noms de variables non
        utilisées.
    }
    \Sortie{
        Une forme lin\'eaire correcte $l'$ telle que $l'$ ne contient aucun
        appel à une fonction de $E$ et est récursivement terminale pour toute
        fonction de $nouveau\_nom(E)$.
    }

    \uSi{$l$ ne contient aucune application de fonction dont le receveur est
        dans $E$}{
        $a \leftarrow$ Le dernier motif de $l$ \\ % TODO: N'est pas nécessairement une variable.
        $p \leftarrow$ Un nom de variable non utilisé dans $l$ \\
        Renvoyer $l.[(p, cont\ a)]$
    }
    \uSinon{
    $e \leftarrow$ Le premier élément de $l$ contenant une application d'une
    fonction de $E$ \\
    $a \leftarrow$ Le motif associé \`a $e$ dans $l$ \\
    $l_1 \leftarrow$ Les éléments de $l$ situés avant $e$ \\
    $l_2 \leftarrow$ Les éléments de $l$ situés après $e$ \\



    \uSi{$l_2$ est vide}{
    \uSi{$e$ est un appel \`a une fonction $f$ de $E$}{
        $e_{rec} \leftarrow$ Un appel \`a $nouveau\_nom(f)$ avec en arguments les
        arguments de $e$ suivis de $cont$.
    }\uSinon{
        $e_{rec} \leftarrow$ $e$ avec chacun de ses fils localement terminaux
        $f$ remplacés par la valeur de
        Rectifier($f$, $E$, $cont$, $nouveau\_nom$)
    }
    Renvoyer $l_1.[(a, e_{rec})]$
    }\uSinon{
    $l_{2,rec} \leftarrow$ Rectifier($l_2$, $E$, $cont$) \\
    $cont' \leftarrow$ Un nom de variable non utilisé dans $l$ différent de
    $cont$. \\
    \uSi{$e$ est un appel \`a une fonction $f$ de $E$}{
        $e_{rec} \leftarrow$ Un appel \`a $nouveau\_nom(f)$ avec en arguments les
        arguments de $e$ suivis de $cont'$
    }\uSinon{
        $e_{rec} \leftarrow$ $e$ avec chacun de ses fils localement terminaux
        $f$ remplacés par la valeur de
        Rectifier($f$, $E$, $cont'$, $nouveau\_nom$)
    }
    Renvoyer $l_1.[(cont', \texttt{fun } a \texttt{ -> } l_{2,rec}), (a, e_{rec})]$
    }
    }
\end{algorithm}

Montrons alors la correction de cet algorithme.

\begin{lemma}
    Si $l$ est réduit à un seul couple $(p, e)$ avec $e$ un constructeur d'arité
    nulle, alors $Rectifier(l, E, cont, nouveau\_num) = l$.
\end{lemma}

\begin{proof}
    $l$ ne peut pas contenir d'application de fonction dont le receveur est dans
    $E$. Ainsi $Rectifier(l, E, cont, nouveau\_num) = l$.
\end{proof}

\begin{proposition}
    La forme linéaire renvoyée par Rectifier est correcte.
\end{proposition}

\begin{proof}
    \hl{TODO: Needs revisiting}

    Notons $P(h): \forall l \textnormal{ forme linéaire correcte de hauteur } h,
        \forall E \textnormal{ rectifiable}, \\ \forall cont \textnormal{ nom de
            variable}, \forall nouveau\_nom : E \rightarrow \textnormal{ noms de
            variables},\\ Rectifier(l, e, cont, nouveau\_nom)$ est correct.

    Montrons P($h$) pour tout $h \geq 0$ par récurrence sur $h$.

    \begin{itemize}
        \item Pour $h = 0$ : \\
              Soit $l$ de hauteur nulle, ainsi que $E$, $cont$ et $nouveau\_nom$
              des entrées de Rectifier. \\
              Les éléments de de $l$ sont alors forcément des constructeurs
              d'arité nulle. $l$ ne contient alors pas d'application de fonction
              donc $Rectifier(l, E, cont, nouveau\_nom) = l$ est ainsi correct.

        \item Soit $h \geq 0$. Supposons $P(i)$ pour tout $i \in \lBrack 0; h \rBrack$. \\
              Notons $Q(n) : \forall l \textnormal{ forme linéaire correcte de
                      hauteur inférieure à } h + 1 \textnormal{ et de longueur } n,
                  \\ \forall E \textnormal{ rectifiable}, \forall cont
                  \textnormal{ nom de variable}, \forall nouveau\_nom : E
                  \rightarrow \textnormal{ noms de variables},\\ Rectifier(l, e,
                  cont, nouveau\_nom)$ est correct.\\
              Montrons Q($n$) pour tout $n \ge 0$ par récurrence.

              \begin{itemize}
                  \item Pour $n = 1$ : \\
                        Soit $l$ de hauteur au plus $h + 1$ et de longueur $1$,
                        ainsi que $E$, $cont$, $nouveau\_nom$ des entrées de
                        Rectifier. \\
                        On distingue alors trois cas:
                        \begin{itemize}
                            \item Si $l$ ne contient aucune application d'une
                                  fonction de $E$ : \\
                                  Alors $Rectifier(l, E, cont, nouveau\_nom) = l$ est correct.
                            \item Si $l$ est réduit à une seule application
                                  d'une fonction  $f$ de $E$ : \\
                                  Alors $Rectifier(l, E, cont, nouveau\_nom)$
                                  est un appel à $nouveau\_nom(f)$ avec les
                                  mêmes arguments suivis de $cont$. Cette
                                  application reste un élément linéaire dont
                                  tous les fils sont des formes linéaires
                                  réduites à un seul couple dont les éléments
                                  linéaires sont des constructeurs d'arité
                                  nulle ($nouveau\_nom(f)$ et $cont$ sont des
                                  variables donc bien d'arité nulle).
                                  $Rectifier(l, E, cont, nouveau\_nom)$ est donc
                                  correct ($l_1$ est vide).
                            \item Sinon, $l$ contient un seul couple $(p, e)$
                                  qui contient un appel à une fonction de $E$.
                                  En notant $C$ le constructeur de $e$ et $l_1,
                                      \ldots, l_m$ ses fils, on a alors \\
                                  $Rectifier(l, E, cont, nouveau\_nom) = \newline [(p, C(Rectifier(l_1, E, cont, nouveau\_nom), \ldots))]$. \\
                                  Considérons alors $e$ dans
                                  $Rectifier(l, E, cont, nouveau\_nom)$.
                                  On distingue alors deux cas:
                                  \begin{itemize}
                                      \item Si $e$ est dans l'un des
                                            $Rectifier(l_i, E, cont, nouveau\_nom)$ : \\
                                            Alors, comme $Rectifier(l_i, E, cont, nouveau\_nom)$
                                            est correct d'après \\ $P(haut(l_i))$,
                                            $e$ est correct.
                                      \item Si $e = C(Rectifier(l_1, E, cont, nouveau\_nom), \ldots)$ : \\
                                            Soit alors $f$ un fils de $e$. Il
                                            existe alors $i$ tel que \\
                                            $f = Rectifier(l_i, E, cont, nouveau\_nom)$.
                                            En particulier $f$ est localement
                                            terminal ssi $l_i$ est localement
                                            terminal. Alors, si $f$ n'est pas
                                            localement terminal, $l_i$ ne l'est
                                            pas non plus. Or comme $l$ est
                                            correct, si $l_i$ n'est pas
                                            localement terminal alors $l_i$ est
                                            réduit à un seul couple dont
                                            l'élément est un constructeur
                                            d'arité nulle. Alors $f$ est aussi
                                            réduit à un seul couple dont
                                            l'élément est un constructeur
                                            d'arité nulle d'après le lemme. \\
                                            $e$ est alors bien correct.
                                  \end{itemize}
                                  $Rectifier(l, E, cont, nouveau\_nom)$ est
                                  ainsi bien correct.
                        \end{itemize}
                        Ainsi on vérifie bien $Q(0)$.
                  \item Soit $n \geq 0$. Supposons $Q(i)$ pour tout $i \in \lBrack 0; n \rBrack$.
                        Montrons $Q(n + 1)$. \\
                        Soit alors $l$ de hauteur au plus $h + 1$ et de longueur
                        $n + 1$, ainsi que $E$, $cont$, $nouveau\_nom$ des
                        entrées de rectifier. \\
                        On distingue alors deux cas :
                        \begin{itemize}
                            \item Si $l$ ne contient aucune application d'une fonction de
                                  $E$ : \\
                                  Alors $Rectifier(l, E, cont, nouveau\_nom) = l$
                                  est correct.
                            \item Sinon, $l$ contient une application d'une
                                  fonction de $E$. \\
                                  $l_{2,rec}$ est correct d'après $Q(|l_2|)$.
                                  $e_{rec}$ est correct d'après les mêmes
                                  arguments qui ci-dessus. $l_1$ est correct car
                                  $l$ est correct. \\
                                  Ainsi $Rectifier(l, E, cont, nouveau\_nom) = l_1.[(cont', \texttt{fun } a \texttt{ -> } l_{2,rec}), (a, e_{rec})]$
                                  est correct ($l_{2,rec}$ est localement
                                  terminale car elle n'apparaît jamais dans l'ordre
                                  d'exécution de $\texttt{fun } a \texttt{ -> } l_{2,rec}$).
                        \end{itemize}
                        On vérifie alors $Q(i + 1)$.
              \end{itemize}
              On a alors, pour tout $n \in \mathbf{N}$, $Q(n)$. Or on obtient
              alors $P(h + 1)$.
    \end{itemize}
    Ainsi pour tout $h \in \mathbf{N}$, $P(h)$ est vrai et donc pour toute
    entrée de Rectifier, la forme linéaire renvoyée est correcte.
\end{proof}


\begin{proposition}
    \hl{TODO: Needs revisiting} \\
    La forme linéaire renvoyée par Rectifier est récursivement terminale pour
    toute fonction de $nouveau\_nom(E)$.
\end{proposition}

\begin{proof}
    Soit $l$, $E$, $cont$ et $nouveau\_nom$ une entrée de Rectifier. Soit \\
    $f \in nouveau\_nom(E)$. Montrons que $l$ est récursivement terminale pour
    $f$. \\
    Si un élément linéaire contient un appel à $f$, c'est forcément puisque un
    appel à une autre fonction a été remplacée dans $l$ (puisque les $f$ ne peut
    pas apparaître dans $l$). En considérant les deux instructions
    \textit{Renvoyer} de l'algorithme, cet élément linéaire est forcément le
    dernier dans la forme linéaire le contenant. De plus, si $l'$ est une forme
    linéaire strictement contenue dans $l$ qui contient $e$, alors $l'$ est
    localement terminal car sinon $l$ ne serait pas correct. $l$ est donc
    récursivement terminale pour $f$.
\end{proof}

\subsection{Application}

Soit $E = \{f_1, \ldots, f_n\}$ un ensemble de noms de fonctions
définies par $f_i: x_1, \ldots, x_n \rightarrowtail \textnormal{Eval}(l_i, [x_1 \rightarrow x_1, \ldots, x_n \rightarrow x_n])$
tel que $E$ soit rectifiable.

Construisons un ensemble de fonctions $\{f_1', \ldots, f_n'\}$ par $f_i' : x_1 \rightarrow x_1, \ldots, x_n, \texttt{cont} \rightarrowtail \textnormal{Eval}(\textnormal{Rectifier}(l_i, E, \texttt{cont}, nouveau\_nom), [x_1 \rightarrow x_1, \ldots, x_n \rightarrow x_n, \texttt{cont} \rightarrow \texttt{cont}])$
avec \\ $nouveau\_nom$ défini par $f_i \rightarrowtail f_i'$.

Montrons alors que, pour tout $f_i \in E$, pour toute fonction $g$ de type
compatible, $g (f_i\ x_1\ \ldots\ x_n)$ est équivalent à $f_i'\ x_1\ \ldots\ x_n\ g$.

On pourra alors redéfinir les $f_i$ par $f_i: x_1, \ldots, x_n \rightarrowtail f_i'\ x_1\ \ldots\ x_n\ \texttt{(fun x -> x)}$
pour obtenir un programme équivalent mais o\`u les $f_i'$ sont mutuellement
récursives terminales.

\begin{proof}
    \hl{TODO}
\end{proof}

Pour rectifier un ensemble de fonctions $\{f_1, \ldots, f_n\}$ arbitraire, il
nous faut alors un moyen de calculer un ensemble rectifiable qui contient tous
les $f_i$. On introduit alors l'algorithme suivant :

\begin{algorithm}[H]
    \caption{Cl\^oture\_rectifiable}
    \Entree{Un ensemble $\{f_1, \ldots, f_n\}$ de noms de variables}
    \Sortie{
        Un ensemble $\{g_1, \ldots, g_m\}$ de noms de variables rectifiable qui
        contient tous les $f_i$, ou \texttt{None}
    }
\end{algorithm}

