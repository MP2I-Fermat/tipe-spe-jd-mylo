\section{Rectification}

\subsection{R\'ecursivit\'e terminale}

\begin{definition}
    Forme linéaire terminale récursive.
    \newline
    On dit qu'une forme linéaire $l$ est récursivement terminale pour une
    fonction $f$ si \'el\'ement lin\'eaire contenu dans $l$ dont l'\'evaluation
    conduit \`a un appel de $f$ est terminal.
\end{definition}

\begin{definition}
    R\'ecursitivit\'e terminale
    \newline
    Soit $f$ une \hl{fonction} r\'ecursive d\'efinie par
    $f: x_1, \ldots, x_n \rightarrowtail \textnormal{Eval}(l, [x_1 \rightarrow x_1, \ldots, x_n \rightarrow x_n])$
    (c'est-\`a-dire qu'un appel \`a $f$ \'evalue $l$ en mettant les variables
    $x_1$ \`a $x_n$ aux valeurs donn\'ees en argument \`a la fonction).

    On dit que $f$ est \textit{r\'ecursive terminale} si tout $l$ est
    récursivement terminal pour $f$.
\end{definition}

\begin{example}
    \begin{align*}
        f : l \rightarrowtail \textnormal{Eval} \left(
        \begin{aligned}
             & a_1 := \texttt{List.is\_empty}\ l                                                     \\
             & a_2 := \texttt{if}\ a_1\ \texttt{then true else}\ \left(\begin{aligned}
                                                                                & a_3 := \texttt{List.tl}\ l \\
                                                                                & a_4 := \texttt{f}\ a_3     \\
                                                                                & a_5 := \texttt{not}\ a_4
                                                                           \end{aligned}\right)
        \end{aligned}, [l \rightarrow l] \right)
    \end{align*}

    Cette fonction calcule si son argument $l$ est une liste de longueur paire.
    Elle n'est pas r\'ecursive terminale car l'appel $\texttt{f}\ a_3$ n'est pas
    terminal.

    \begin{align*}
        g : l \rightarrowtail \textnormal{Eval} \left(
        \begin{aligned}
             & a_1 := \texttt{List.length}\ l                                     \\
             & a_2 := a_1 = 0                                                     \\
             & a_3 := \texttt{if}\ a_2\ \texttt{then failwith "Liste vide"}       \\
             & a_4 := a_1 = 1                                                     \\
             & a_5 := \texttt{List.hd}\ l                                         \\
             & a_6 := \texttt{List.tl}\ l                                         \\
             & a_5 := \texttt{if}\ a_4\ \texttt{then}\ a_5\ \texttt{else g} \ a_6
        \end{aligned}, [l \rightarrow l]
        \right)
    \end{align*}

    Cette fonction renvoie le dernier \'el\'ement de la liste $l$ donn\'ee en
    argument. Elle est r\'ecursive terminale car l'appel $\texttt{g} \ a_6$ est
    terminal.
\end{example}

\begin{definition}
    Fonctions mutuellement r\'ecursives terminales
    \newline
    On dit qu'un ensemble de fonctions $\{f_1, \ldots, f_n\}$ toutes d\'efinies
    comme ci-dessus sont mutuellement r\'ecursives terminales si, pour toute
    fonction $f_i$ d\'efinie par un appel \`a Eval($l_i$, $c$) et pour toute fonction
    $f_j$, $l_i$ est récursivement terminal pour $f_j$.
\end{definition}


\subsection{Rectification}

\begin{definition}
    Formes lin\'eaires \'equivalentes
    \newline
    On dit que deux formes lin\'eaires $l_1$ et $l_2$ sont
    \textit{\'equivalentes} lorsque Eval($l_1$, $c$) a le m\^eme r\'esultat que
    Eval($l_2$, $c$) pour tout contexte $c$.
\end{definition}

On introduit alors un algorithme permettant de \textit{rectifier} une forme
lin\'eaire $l$, c'est \`a dire de calculer une forme lin\'eaire r\'ecursive
terminale \'equivalente \`a $l$.

\begin{definition}
    Application complète d'une fonction \texttt{OCaml}
    \newline
    On dit qu'une application de fonction (un élément d'un arbre de syntaxe
    abstrait \texttt{OCaml}) est \textit{complète} lorsque le nombre d'arguments
    de l'application correspond exactement au nombre de paramètres de la
    fonction appelée.
\end{definition}

\begin{definition}
    Ensemble de fonctions rectifiable
    \newline
    Soit $E = \{f_1, \ldots, f_n\}$ un ensemble de fonctions. On dit que $E$ est
    \textit{rectifiable} lorsque :
    \begin{itemize}
        \item Toute fonction $f_i \in E$ est définie par
              $f_i: x_1, \ldots, x_n \rightarrowtail \textnormal{Eval}(l_i, [x_1 \rightarrow x_1, \ldots, x_n \rightarrow x_n])$
        \item Pour tout $f_i \in E$, pour tout $l_j$, toute application de $f_i$
              contenue dans $l_j$ est complète.
        \item Pour tout $f_i \in E$, pour toute fonction $g$ définie dans $f_i$
              (par recours aux constructeurs \texttt{let g \ldots = \ldots} ou
              \texttt{fun \ldots -> \ldots}), $g \in E$ (i.e tout appel d'une
              fonction dans $E$ est elle-même dans une fonction de $E$).
    \end{itemize}
\end{definition}

\begin{algorithm}[H]
    \caption{Rectifier}
    \Entree{
        Une forme lin\'eaire correcte $l$, un ensemble de fonctions
        rectifiable $E$, un nom de variable non utilisée dans $l$ $cont$ et une
        fonction $nouveau\_nom$ de $E$ dans les noms de variables.
    }
    \Sortie{
        Une forme lin\'eaire correcte $l'$ telle que $l'$ est récursivement terminal pour toute fonction de $E$.
    }

    \uSi{$l$ ne contient aucun élément dont l'évaluation conduirait \`a un appel
        d'une fonction de $E$}{
        Renvoyer $l$
    }
    \uSinon{
    $e \leftarrow$ Le premier élément de $l$ dont l'évaluation conduirait \`a un
    appel d'une fonction de $E$ \\
    $a \leftarrow$ Le motif associé \`a $e$ dans $l$ \\
    $l_1 \leftarrow$ Les éléments de $l$ situés avant $e$ \\
    $l_2 \leftarrow$ Les éléments de $l$ situés après $e$ \\



    \uSi{$l_2$ est vide}{
    \uSi{$e$ est un appel \`a une fonction $f$ de $E$}{
        $e_{rec} \leftarrow$ Un appel \`a $nouveau\_nom(f)$ avec en arguments les
        arguments de $e$ suivis de $cont$.
    }\uSinon{
        $e_{rec} \leftarrow$ $e$ avec chacun de ses fils $f$ remplacés par la
        valeur de Rectifier($f$, $E$, $cont$)
    }
    Renvoyer $l_1.[(a, e_{rec})]$
    }\uSinon{
    $l_{2,rec} \leftarrow$ Rectifier($l_2$, $E$, $cont$) \\
    $cont' \leftarrow$ Un nom de variable non utilisé dans $l$ différent de
    $cont$. \\
    \uSi{$e$ est un appel \`a une fonction $f$ de $E$}{
        $e_{rec} \leftarrow$ Un appel \`a $nouveau\_nom(f)$ avec en arguments les
        arguments de $e$ suivis de $cont'$.
    }\uSinon{
        $e_{rec} \leftarrow$ $e$ avec chacun de ses fils $f$ remplacés par la
        valeur de Rectifier($f$, $E$, $cont'$)
    }
    Renvoyer $l_1.[(cont', \texttt{fun } a \texttt{ -> } l_{2,rec}), (a, e_{rec})]$
    }
    }
\end{algorithm}

Montrons alors la correction de cet algorithme. Soient $l$ et
$\{f_1, \ldots, f_n\}$ une entr\'ee valide et
$l' = \textnormal{Rectifier}(l, \{f_1, \ldots, f_n\})$.

\begin{proposition}
    $l'$ est \'equivalente \`a $l$
\end{proposition}

\begin{proof}
    \hl{TODO}
\end{proof}


\begin{proposition}
    Pour tout $f \in \{f_1, \ldots, f_i\}$, tout \'el\'ement lin\'eaire contenu
    (au sens des arbres) dans $l'$ dont l'\'evaluation conduit \`a un appel de
    $f$ est terminale dans $l'$
\end{proposition}

\begin{proof}
    \hl{TODO}
\end{proof}

\begin{proposition}
    Rectifier permet de rectifier des fonctions
    \newline
    \hl{TODO}
\end{proposition}
